import json
import re
import requests
import socket
import time
from typing import Dict, List, Optional, Tuple
import threading
from concurrent.futures import ThreadPoolExecutor
import os
from dataclasses import dataclass, asdict
from enum import Enum

class VulnerabilityLevel(Enum):
    CRITICAL = "Critical"
    HIGH = "High"
    MEDIUM = "Medium"
    LOW = "Low"
    INFO = "Info"

@dataclass
class Vulnerability:
    cve_id: str
    title: str
    description: str
    severity: VulnerabilityLevel
    cvss_score: float
    affected_service: str
    affected_version: str
    solution: str
    references: List[str]
    exploit_available: bool = False

class VulnerabilityScanner:
    
    def __init__(self, timeout: float = 5.0, max_threads: int = 20):

        self.timeout = timeout
        self.max_threads = max_threads
        self.vulnerabilities_db = {}
        self.scan_results = {}
        
        self.load_vulnerability_database()
        self.load_exploit_database()
        
        self.session = requests.Session()
        self.session.timeout = timeout
        
    def load_vulnerability_database(self):
        try:
            with open('data/vulnerabilities.json', 'r', encoding='utf-8') as f:
                data = json.load(f)
                self.vulnerabilities_db = data
        except FileNotFoundError:
            self.vulnerabilities_db = {
                "web_vulnerabilities": {
                    "sql_injection": {
                        "patterns": ["error in your SQL syntax", "mysql_fetch", "ORA-", "Microsoft OLE DB"],
                        "severity": "HIGH",
                        "description": "SQL Injection vulnerability detected"
                    },
                    "xss": {
                        "patterns": ["<script>", "javascript:", "onerror=", "onload="],
                        "severity": "MEDIUM",
                        "description": "Cross-Site Scripting (XSS) vulnerability"
                    }
                },
                "service_vulnerabilities": {
                    "apache": {
                        "2.4.29": ["CVE-2018-1312", "CVE-2018-1283"],
                        "2.4.33": ["CVE-2018-11763"],
                        "2.2.15": ["CVE-2017-7679", "CVE-2017-3167"]
                    },
                    "nginx": {
                        "1.10.3": ["CVE-2017-7529"],
                        "1.12.2": ["CVE-2018-16843", "CVE-2018-16844"]
                    },
                    "openssh": {
                        "7.4": ["CVE-2018-15919", "CVE-2018-15473"],
                        "6.6.1": ["CVE-2016-0777", "CVE-2016-0778"]
                    }
                }
            }
    
    def load_exploit_database(self):
        try:
            with open('data/exploits.json', 'r', encoding='utf-8') as f:
                self.exploit_db = json.load(f)
        except FileNotFoundError:
            self.exploit_db = {}
    
    def scan_service_vulnerabilities(self, host: str, port: int, 
                                   service: str, version: str = "") -> List[Vulnerability]:

        vulnerabilities = []
        
        try:
            service_vulns = self._check_service_version_vulnerabilities(service, version)
            vulnerabilities.extend(service_vulns)
            
            if service.lower() in ['http', 'https', 'apache', 'nginx', 'iis']:
                web_vulns = self._scan_web_vulnerabilities(host, port)
                vulnerabilities.extend(web_vulns)
            
            elif service.lower() in ['ssh', 'openssh']:
                ssh_vulns = self._scan_ssh_vulnerabilities(host, port, version)
                vulnerabilities.extend(ssh_vulns)
            
            elif service.lower() in ['ftp', 'ftps']:
                ftp_vulns = self._scan_ftp_vulnerabilities(host, port, version)
                vulnerabilities.extend(ftp_vulns)
            
            elif service.lower() in ['smtp', 'smtps']:
                smtp_vulns = self._scan_smtp_vulnerabilities(host, port, version)
                vulnerabilities.extend(smtp_vulns)
            
            general_vulns = self._scan_general_vulnerabilities(host, port, service)
            vulnerabilities.extend(general_vulns)
            
        except Exception as e:
            print(f"Servis tarama hatası {host}:{port} -> {str(e)}")
        
        return vulnerabilities
    
    def _check_service_version_vulnerabilities(self, service: str, version: str) -> List[Vulnerability]:
    
        vulnerabilities = []
        
        if not version:
            return vulnerabilities
        
        service_lower = service.lower()
        service_vulns = self.vulnerabilities_db.get('service_vulnerabilities', {})
        
        if 'apache' in service_lower and 'apache' in service_vulns:
            apache_vulns = service_vulns['apache']
            for vuln_version, cve_list in apache_vulns.items():
                if self._version_matches(version, vuln_version):
                    for cve in cve_list:
                        vuln = Vulnerability(
                            cve_id=cve,
                            title=f"Apache {vuln_version} Vulnerability",
                            description=f"Apache version {version} is vulnerable to {cve}",
                            severity=VulnerabilityLevel.HIGH,
                            cvss_score=7.5,
                            affected_service="Apache HTTP Server",
                            affected_version=version,
                            solution="Update Apache to the latest version",
                            references=[f"https://cve.mitre.org/cgi-bin/cvename.cgi?name={cve}"],
                            exploit_available=cve in self.exploit_db
                        )
                        vulnerabilities.append(vuln)
        
        if 'nginx' in service_lower and 'nginx' in service_vulns:
            nginx_vulns = service_vulns['nginx']
            for vuln_version, cve_list in nginx_vulns.items():
                if self._version_matches(version, vuln_version):
                    for cve in cve_list:
                        vuln = Vulnerability(
                            cve_id=cve,
                            title=f"Nginx {vuln_version} Vulnerability",
                            description=f"Nginx version {version} is vulnerable to {cve}",
                            severity=VulnerabilityLevel.MEDIUM,
                            cvss_score=6.4,
                            affected_service="Nginx",
                            affected_version=version,
                            solution="Update Nginx to the latest version",
                            references=[f"https://cve.mitre.org/cgi-bin/cvename.cgi?name={cve}"],
                            exploit_available=cve in self.exploit_db
                        )
                        vulnerabilities.append(vuln)
        
        if 'ssh' in service_lower and 'openssh' in service_vulns:
            ssh_vulns = service_vulns['openssh']
            for vuln_version, cve_list in ssh_vulns.items():
                if self._version_matches(version, vuln_version):
                    for cve in cve_list:
                        vuln = Vulnerability(
                            cve_id=cve,
                            title=f"OpenSSH {vuln_version} Vulnerability",
                            description=f"OpenSSH version {version} is vulnerable to {cve}",
                            severity=VulnerabilityLevel.HIGH,
                            cvss_score=8.1,
                            affected_service="OpenSSH",
                            affected_version=version,
                            solution="Update OpenSSH to the latest version",
                            references=[f"https://cve.mitre.org/cgi-bin/cvename.cgi?name={cve}"],
                            exploit_available=cve in self.exploit_db
                        )
                        vulnerabilities.append(vuln)
        
        return vulnerabilities
    
    def _version_matches(self, current_version: str, vulnerable_version: str) -> bool:
    
        try:
            current_parts = [int(x) for x in current_version.split('.')]
            vuln_parts = [int(x) for x in vulnerable_version.split('.')]
            
            for i in range(min(len(current_parts), len(vuln_parts))):
                if current_parts[i] < vuln_parts[i]:
                    return False
                elif current_parts[i] > vuln_parts[i]:
                    return True
            
            return len(current_parts) <= len(vuln_parts)
        except:
            return current_version == vulnerable_version
    
    def _scan_web_vulnerabilities(self, host: str, port: int) -> List[Vulnerability]:
       
        vulnerabilities = []
        base_url = f"http://{host}:{port}" if port != 443 else f"https://{host}:{port}"
        
        try:
            sql_vulns = self._test_sql_injection(base_url)
            vulnerabilities.extend(sql_vulns)
            
            xss_vulns = self._test_xss(base_url)
            vulnerabilities.extend(xss_vulns)
            
            dir_vulns = self._test_directory_traversal(base_url)
            vulnerabilities.extend(dir_vulns)
            
            header_vulns = self._test_security_headers(base_url)
            vulnerabilities.extend(header_vulns)
            
        except Exception as e:
            print(f"Web güvenlik tarama hatası: {str(e)}")
        
        return vulnerabilities
    
    def _test_sql_injection(self, base_url: str) -> List[Vulnerability]:
        
        vulnerabilities = []
        
        payloads = [
            "' OR '1'='1",
            "' OR 1=1--",
            "' UNION SELECT NULL--",
            "'; DROP TABLE users--"
        ]
        
        test_params = ['id', 'user', 'search', 'q', 'name']
        
        for payload in payloads:
            for param in test_params:
                try:
                    response = self.session.get(
                        f"{base_url}/",
                        params={param: payload},
                        timeout=self.timeout
                    )
                    
                    sql_errors = [
                        "error in your SQL syntax",
                        "mysql_fetch",
                        "ORA-",
                        "Microsoft OLE DB",
                        "PostgreSQL query failed"
                    ]
                    
                    response_text = response.text.lower()
                    for error in sql_errors:
                        if error.lower() in response_text:
                            vuln = Vulnerability(
                                cve_id="SQL-INJ-001",
                                title="SQL Injection Vulnerability",
                                description=f"SQL injection vulnerability detected in parameter '{param}'",
                                severity=VulnerabilityLevel.HIGH,
                                cvss_score=8.8,
                                affected_service="Web Application",
                                affected_version="Unknown",
                                solution="Use parameterized queries and input validation",
                                references=[
                                    "https://owasp.org/www-community/attacks/SQL_Injection",
                                    "https://cwe.mitre.org/data/definitions/89.html"
                                ],
                                exploit_available=True
                            )
                            vulnerabilities.append(vuln)
                            break
                            
                except Exception:
                    continue
        
        return vulnerabilities
    
    def _test_xss(self, base_url: str) -> List[Vulnerability]:
      
        vulnerabilities = []
        
        payloads = [
            "<script>alert('XSS')</script>",
            "<img src=x onerror=alert('XSS')>",
            "javascript:alert('XSS')",
            "<svg onload=alert('XSS')>"
        ]
        
        test_params = ['search', 'q', 'query', 'input', 'data']
        
        for payload in payloads:
            for param in test_params:
                try:
                    response = self.session.get(
                        f"{base_url}/",
                        params={param: payload},
                        timeout=self.timeout
                    )
                    
                    if payload in response.text:
                        vuln = Vulnerability(
                            cve_id="XSS-001",
                            title="Cross-Site Scripting (XSS) Vulnerability",
                            description=f"Reflected XSS vulnerability detected in parameter '{param}'",
                            severity=VulnerabilityLevel.MEDIUM,
                            cvss_score=6.1,
                            affected_service="Web Application",
                            affected_version="Unknown",
                            solution="Implement proper input validation and output encoding",
                            references=[
                                "https://owasp.org/www-community/attacks/xss/",
                                "https://cwe.mitre.org/data/definitions/79.html"
                            ],
                            exploit_available=True
                        )
                        vulnerabilities.append(vuln)
                        break
                        
                except Exception:
                    continue
        
        return vulnerabilities
    
    def _test_directory_traversal(self, base_url: str) -> List[Vulnerability]:
     
        vulnerabilities = []
        
        payloads = [
            "../../../etc/passwd",
            "..\\..\\..\\windows\\system32\\drivers\\etc\\hosts",
            "....//....//....//etc/passwd",
            "%2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fpasswd"
        ]
        
        test_params = ['file', 'path', 'page', 'include', 'template']
        
        for payload in payloads:
            for param in test_params:
                try:
                    response = self.session.get(
                        f"{base_url}/",
                        params={param: payload},
                        timeout=self.timeout
                    )
                    
                    # Unix/Linux sistem dosyası içeriğini kontrol et
                    if "root:x:0:0:" in response.text or "127.0.0.1" in response.text:
                        vuln = Vulnerability(
                            cve_id="DIR-TRAV-001",
                            title="Directory Traversal Vulnerability",
                            description=f"Directory traversal vulnerability detected in parameter '{param}'",
                            severity=VulnerabilityLevel.HIGH,
                            cvss_score=7.5,
                            affected_service="Web Application",
                            affected_version="Unknown",
                            solution="Implement proper input validation and file access controls",
                            references=[
                                "https://owasp.org/www-community/attacks/Path_Traversal",
                                "https://cwe.mitre.org/data/definitions/22.html"
                            ],
                            exploit_available=True
                        )
                        vulnerabilities.append(vuln)
                        break
                        
                except Exception:
                    continue
        
        return vulnerabilities
    
    def _test_security_headers(self, base_url: str) -> List[Vulnerability]:
   
        vulnerabilities = []
        
        try:
            response = self.session.get(base_url, timeout=self.timeout)
            headers = response.headers
            
            security_headers = {
                'X-Frame-Options': 'Clickjacking protection missing',
                'X-Content-Type-Options': 'MIME type sniffing protection missing',
                'X-XSS-Protection': 'XSS protection disabled',
                'Strict-Transport-Security': 'HTTPS enforcement missing',
                'Content-Security-Policy': 'Content Security Policy missing'
            }
            
            for header, description in security_headers.items():
                if header not in headers:
                    vuln = Vulnerability(
                        cve_id=f"SEC-HEADER-{header.replace('-', '')}",
                        title=f"Missing Security Header: {header}",
                        description=description,
                        severity=VulnerabilityLevel.LOW,
                        cvss_score=3.1,
                        affected_service="Web Server",
                        affected_version="Unknown",
                        solution=f"Add {header} header to server configuration",
                        references=[
                            "https://owasp.org/www-project-secure-headers/",
                            "https://securityheaders.com/"
                        ],
                        exploit_available=False
                    )
                    vulnerabilities.append(vuln)
                    
        except Exception:
            pass
        
        return vulnerabilities
    
    def _scan_ssh_vulnerabilities(self, host: str, port: int, version: str) -> List[Vulnerability]:
      
        vulnerabilities = []
        
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(self.timeout)
            sock.connect((host, port))
            banner = sock.recv(1024).decode('utf-8', errors='ignore')
            sock.close()
            
            if 'password' in banner.lower():
                vuln = Vulnerability(
                    cve_id="SSH-WEAK-001",
                    title="SSH Password Authentication Enabled",
                    description="SSH server allows password authentication which is less secure than key-based authentication",
                    severity=VulnerabilityLevel.MEDIUM,
                    cvss_score=5.3,
                    affected_service="SSH",
                    affected_version=version,
                    solution="Disable password authentication and use SSH keys",
                    references=["https://www.ssh.com/academy/ssh/public-key-authentication"],
                    exploit_available=False
                )
                vulnerabilities.append(vuln)
                
        except Exception:
            pass
        
        return vulnerabilities
    
    def _scan_ftp_vulnerabilities(self, host: str, port: int, version: str) -> List[Vulnerability]:
      
        vulnerabilities = []
        
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(self.timeout)
            sock.connect((host, port))
            
            banner = sock.recv(1024).decode('utf-8', errors='ignore')
            
            sock.send(b'USER anonymous\r\n')
            response = sock.recv(1024).decode('utf-8', errors='ignore')
            
            if '230' in response or '331' in response:
                vuln = Vulnerability(
                    cve_id="FTP-ANON-001",
                    title="Anonymous FTP Access Enabled",
                    description="FTP server allows anonymous access",
                    severity=VulnerabilityLevel.MEDIUM,
                    cvss_score=5.3,
                    affected_service="FTP",
                    affected_version=version,
                    solution="Disable anonymous FTP access",
                    references=["https://www.cert.org/advisories/CA-1999-03.html"],
                    exploit_available=False
                )
                vulnerabilities.append(vuln)
            
            sock.close()
            
        except Exception:
            pass
        
        return vulnerabilities
    
    def _scan_smtp_vulnerabilities(self, host: str, port: int, version: str) -> List[Vulnerability]:
       
        vulnerabilities = []
        
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(self.timeout)
            sock.connect((host, port))
            
            banner = sock.recv(1024).decode('utf-8', errors='ignore')
            
            sock.send(b'HELO test\r\n')
            sock.recv(1024)
            
            sock.send(b'MAIL FROM: test@test.com\r\n')
            mail_response = sock.recv(1024).decode('utf-8', errors='ignore')
            
            if '250' in mail_response:
                vuln = Vulnerability(
                    cve_id="SMTP-RELAY-001",
                    title="Potential SMTP Open Relay",
                    description="SMTP server may be configured as an open relay",
                    severity=VulnerabilityLevel.HIGH,
                    cvss_score=7.5,
                    affected_service="SMTP",
                    affected_version=version,
                    solution="Configure SMTP server to prevent unauthorized relaying",
                    references=["https://www.cert.org/advisories/CA-1998-01.html"],
                    exploit_available=False
                )
                vulnerabilities.append(vuln)
            
            sock.close()
            
        except Exception:
            pass
        
        return vulnerabilities
    
    def _scan_general_vulnerabilities(self, host: str, port: int, service: str) -> List[Vulnerability]:
     
        vulnerabilities = []
        
        if self._test_default_credentials(host, port, service):
            vuln = Vulnerability(
                cve_id="DEFAULT-CRED-001",
                title="Default Credentials Detected",
                description=f"Service {service} on port {port} may be using default credentials",
                severity=VulnerabilityLevel.CRITICAL,
                cvss_score=9.8,
                affected_service=service,
                affected_version="Unknown",
                solution="Change default passwords immediately",
                references=["https://cwe.mitre.org/data/definitions/798.html"],
                exploit_available=True
            )
            vulnerabilities.append(vuln)
        
        return vulnerabilities
    
    def _test_default_credentials(self, host: str, port: int, service: str) -> bool:
        
    
        default_creds = {
            'ssh': [('admin', 'admin'), ('root', 'root'), ('admin', 'password')],
            'ftp': [('anonymous', ''), ('admin', 'admin'), ('ftp', 'ftp')],
            'telnet': [('admin', 'admin'), ('root', 'root')],
            'http': [('admin', 'admin'), ('admin', 'password')]
        }
        
        return False  
    
    def generate_vulnerability_report(self, vulnerabilities: List[Vulnerability]) -> Dict:
   
        report = {
            'scan_date': time.strftime('%Y-%m-%d %H:%M:%S'),
            'total_vulnerabilities': len(vulnerabilities),
            'severity_summary': {
                'critical': 0,
                'high': 0,
                'medium': 0,
                'low': 0,
                'info': 0
            },
            'vulnerabilities': []
        }
        
        for vuln in vulnerabilities:
            severity_key = vuln.severity.value.lower()
            if severity_key in report['severity_summary']:
                report['severity_summary'][severity_key] += 1
            
            report['vulnerabilities'].append(asdict(vuln))
        
        return report
    
    def export_report(self, report: Dict, filename: str, format: str = 'json'):
     
        os.makedirs('reports', exist_ok=True)
        filepath = os.path.join('reports', filename)
        
        if format.lower() == 'json':
            with open(f"{filepath}.json", 'w', encoding='utf-8') as f:
                json.dump(report, f, indent=2, ensure_ascii=False, default=str)
        
        elif format.lower() == 'html':
            html_content = self._generate_html_report(report)
            with open(f"{filepath}.html", 'w', encoding='utf-8') as f:
                f.write(html_content)
    
    def _generate_html_report(self, report: Dict) -> str:
       
        html = f"""
        <!DOCTYPE html>
        <html>
        <head>
            <title>Güvenlik Açığı Raporu</title>
            <style>
                body {{ font-family: Arial, sans-serif; margin: 20px; }}
                .critical {{ color: #dc3545; }}
                .high {{ color: #fd7e14; }}
                .medium {{ color: #ffc107; }}
                .low {{ color: #28a745; }}
                .info {{ color: #17a2b8; }}
                table {{ border-collapse: collapse; width: 100%; }}
                th, td {{ border: 1px solid #ddd; padding: 8px; text-align: left; }}
                th {{ background-color: #f2f2f2; }}
            </style>
        </head>
        <body>
            <h1>Güvenlik Açığı Tarama Raporu</h1>
            <p><strong>Tarama Tarihi:</strong> {report['scan_date']}</p>
            <p><strong>Toplam Güvenlik Açığı:</strong> {report['total_vulnerabilities']}</p>
            
            <h2>Severity Özeti</h2>
            <ul>
                <li class="critical">Critical: {report['severity_summary']['critical']}</li>
                <li class="high">High: {report['severity_summary']['high']}</li>
                <li class="medium">Medium: {report['severity_summary']['medium']}</li>
                <li class="low">Low: {report['severity_summary']['low']}</li>
                <li class="info">Info: {report['severity_summary']['info']}</li>
            </ul>
            
            <h2>Detaylar</h2>
            <table>
                <tr>
                    <th>CVE ID</th>
                    <th>Başlık</th>
                    <th>Severity</th>
                    <th>CVSS</th>
                    <th>Servis</th>
                    <th>Açıklama</th>
                </tr>
        """
        
        for vuln in report['vulnerabilities']:
            severity_class = vuln['severity'].lower()
            html += f"""
                <tr>
                    <td>{vuln['cve_id']}</td>
                    <td>{vuln['title']}</td>
                    <td class="{severity_class}">{vuln['severity']}</td>
                    <td>{vuln['cvss_score']}</td>
                    <td>{vuln['affected_service']}</td>
                    <td>{vuln['description']}</td>
                </tr>
            """
        
        html += """
            </table>
        </body>
        </html>
        """
        
        return html


if __name__ == "__main__":
    scanner = VulnerabilityScanner()
    
    print("Vulnerability Scanner Test Başlatılıyor...")
    vulnerabilities = scanner.scan_service_vulnerabilities('127.0.0.1', 80, 'apache', '2.4.29')
    
    if vulnerabilities:
        print(f"Bulunan güvenlik açıkları: {len(vulnerabilities)}")
        for vuln in vulnerabilities:
            print(f"- {vuln.title} ({vuln.severity.value})")
    else:
        print("Güvenlik açığı bulunamadı.")
    
    report = scanner.generate_vulnerability_report(vulnerabilities)
    scanner.export_report(report, 'vulnerability_scan', 'json')