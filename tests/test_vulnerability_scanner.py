"""
SecuriPy Vulnerability Scanner Unit Tests
"""

import unittest
import sys
import os
import json
import time
import threading
import socket
import tempfile
from unittest.mock import Mock, patch, MagicMock, mock_open
from dataclasses import asdict
import requests

# Modül yolunu ekle
sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

from modules.vulnerability_scanner import VulnerabilityScanner, Vulnerability, VulnerabilityLevel

class TestVulnerabilityScanner(unittest.TestCase):
    """Vulnerability Scanner test sınıfı"""
    
    def setUp(self):
        """Her test öncesi çağrılır"""
        self.scanner = VulnerabilityScanner(timeout=1.0, max_threads=5)
        self.test_host = "127.0.0.1"
        self.test_port = 80
    
    def tearDown(self):
        """Her test sonrası çağrılır"""
        # Session'ı kapat
        if hasattr(self.scanner, 'session'):
            self.scanner.session.close()
    
    def test_scanner_initialization(self):
        """Scanner başlatma testi"""
        self.assertEqual(self.scanner.timeout, 1.0)
        self.assertEqual(self.scanner.max_threads, 5)
        self.assertIsInstance(self.scanner.vulnerabilities_db, dict)
        self.assertIsInstance(self.scanner.scan_results, dict)
        self.assertIsNotNone(self.scanner.session)
    
    def test_vulnerability_dataclass(self):
        """Vulnerability dataclass testi"""
        vuln = Vulnerability(
            cve_id="CVE-2024-0001",
            title="Test Vulnerability",
            description="Test description",
            severity=VulnerabilityLevel.HIGH,
            cvss_score=7.5,
            affected_service="Apache",
            affected_version="2.4.29",
            solution="Update to latest version",
            references=["https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2024-0001"],
            exploit_available=True
        )
        
        self.assertEqual(vuln.cve_id, "CVE-2024-0001")
        self.assertEqual(vuln.severity, VulnerabilityLevel.HIGH)
        self.assertTrue(vuln.exploit_available)
        self.assertEqual(vuln.cvss_score, 7.5)
    
    def test_vulnerability_level_enum(self):
        """VulnerabilityLevel enum testi"""
        self.assertEqual(VulnerabilityLevel.CRITICAL.value, "Critical")
        self.assertEqual(VulnerabilityLevel.HIGH.value, "High")
        self.assertEqual(VulnerabilityLevel.MEDIUM.value, "Medium")
        self.assertEqual(VulnerabilityLevel.LOW.value, "Low")
        self.assertEqual(VulnerabilityLevel.INFO.value, "Info")
    
    @patch('builtins.open', new_callable=mock_open, read_data='{"test": "data"}')
    def test_load_vulnerability_database_success(self, mock_file):
        """Güvenlik açığı veritabanı yükleme başarı testi"""
        scanner = VulnerabilityScanner()
        scanner.load_vulnerability_database()
        
        mock_file.assert_called_with('data/vulnerabilities.json', 'r', encoding='utf-8')
        self.assertEqual(scanner.vulnerabilities_db, {"test": "data"})
    
    @patch('builtins.open', side_effect=FileNotFoundError())
    def test_load_vulnerability_database_file_not_found(self, mock_file):
        """Güvenlik açığı veritabanı dosya bulunamadı testi"""
        scanner = VulnerabilityScanner()
        scanner.load_vulnerability_database()
        
        # Varsayılan veritabanı yüklenmiş olmalı
        self.assertIn('web_vulnerabilities', scanner.vulnerabilities_db)
        self.assertIn('service_vulnerabilities', scanner.vulnerabilities_db)
    
    @patch('builtins.open', new_callable=mock_open, read_data='{"exploit1": "data"}')
    def test_load_exploit_database_success(self, mock_file):
        """Exploit veritabanı yükleme başarı testi"""
        scanner = VulnerabilityScanner()
        scanner.load_exploit_database()
        
        mock_file.assert_called_with('data/exploits.json', 'r', encoding='utf-8')
        self.assertEqual(scanner.exploit_db, {"exploit1": "data"})
    
    @patch('builtins.open', side_effect=FileNotFoundError())
    def test_load_exploit_database_file_not_found(self, mock_file):
        """Exploit veritabanı dosya bulunamadı testi"""
        scanner = VulnerabilityScanner()
        scanner.load_exploit_database()
        
        # Boş exploit veritabanı olmalı
        self.assertEqual(scanner.exploit_db, {})
    
    def test_version_matches_exact(self):
        """Tam versiyon eşleşme testi"""
        self.assertTrue(self.scanner._version_matches("2.4.29", "2.4.29"))
        self.assertFalse(self.scanner._version_matches("2.4.30", "2.4.29"))
    
    def test_version_matches_comparison(self):
        """Versiyon karşılaştırma testi"""
        # Daha düşük versiyon zafiyet içermeli
        self.assertTrue(self.scanner._version_matches("2.4.28", "2.4.29"))
        self.assertTrue(self.scanner._version_matches("2.3.41", "2.4.29"))
        
        # Daha yüksek versiyon güvenli olmalı
        self.assertFalse(self.scanner._version_matches("2.4.30", "2.4.29"))
        self.assertFalse(self.scanner._version_matches("2.5.0", "2.4.29"))
    
    def test_version_matches_invalid_format(self):
        """Geçersiz versiyon formatı testi"""
        # Geçersiz format durumunda string eşleştirme yapmalı
        self.assertTrue(self.scanner._version_matches("invalid", "invalid"))
        self.assertFalse(self.scanner._version_matches("invalid1", "invalid2"))
    
    def test_check_service_version_vulnerabilities_apache(self):
        """Apache servis versiyonu güvenlik açığı testi"""
        # Test veritabanını ayarla
        self.scanner.vulnerabilities_db = {
            'service_vulnerabilities': {
                'apache': {
                    '2.4.29': ['CVE-2018-1312', 'CVE-2018-1283']
                }
            }
        }
        self.scanner.exploit_db = {'CVE-2018-1312': 'exploit_data'}
        
        vulns = self.scanner._check_service_version_vulnerabilities('apache', '2.4.29')
        
        self.assertEqual(len(vulns), 2)
        self.assertEqual(vulns[0].cve_id, 'CVE-2018-1312')
        self.assertEqual(vulns[0].affected_service, 'Apache HTTP Server')
        self.assertTrue(vulns[0].exploit_available)
        self.assertEqual(vulns[1].cve_id, 'CVE-2018-1283')
        self.assertFalse(vulns[1].exploit_available)
    
    def test_check_service_version_vulnerabilities_nginx(self):
        """Nginx servis versiyonu güvenlik açığı testi"""
        self.scanner.vulnerabilities_db = {
            'service_vulnerabilities': {
                'nginx': {
                    '1.10.3': ['CVE-2017-7529']
                }
            }
        }
        
        vulns = self.scanner._check_service_version_vulnerabilities('nginx', '1.10.3')
        
        self.assertEqual(len(vulns), 1)
        self.assertEqual(vulns[0].cve_id, 'CVE-2017-7529')
        self.assertEqual(vulns[0].affected_service, 'Nginx')
        self.assertEqual(vulns[0].severity, VulnerabilityLevel.MEDIUM)
    
    def test_check_service_version_vulnerabilities_ssh(self):
        """SSH servis versiyonu güvenlik açığı testi"""
        self.scanner.vulnerabilities_db = {
            'service_vulnerabilities': {
                'openssh': {
                    '7.4': ['CVE-2018-15919']
                }
            }
        }
        
        vulns = self.scanner._check_service_version_vulnerabilities('openssh', '7.4')
        
        self.assertEqual(len(vulns), 1)
        self.assertEqual(vulns[0].cve_id, 'CVE-2018-15919')
        self.assertEqual(vulns[0].affected_service, 'OpenSSH')
        self.assertEqual(vulns[0].severity, VulnerabilityLevel.HIGH)
    
    def test_check_service_version_vulnerabilities_no_version(self):
        """Versiyon olmadan güvenlik açığı testi"""
        vulns = self.scanner._check_service_version_vulnerabilities('apache', '')
        self.assertEqual(len(vulns), 0)
    
    def test_check_service_version_vulnerabilities_unknown_service(self):
        """Bilinmeyen servis güvenlik açığı testi"""
        vulns = self.scanner._check_service_version_vulnerabilities('unknown_service', '1.0.0')
        self.assertEqual(len(vulns), 0)
    
    @patch('requests.Session.get')
    def test_test_sql_injection_vulnerable(self, mock_get):
        """SQL injection zafiyeti tespit testi"""
        # Mock response ile SQL error döndür
        mock_response = Mock()
        mock_response.text = "Error in your SQL syntax near 'OR 1=1'"
        mock_get.return_value = mock_response
        
        vulns = self.scanner._test_sql_injection("http://test.com")
        
        self.assertGreater(len(vulns), 0)
        self.assertEqual(vulns[0].cve_id, "SQL-INJ-001")
        self.assertEqual(vulns[0].severity, VulnerabilityLevel.HIGH)
        self.assertTrue(vulns[0].exploit_available)
    
    @patch('requests.Session.get')
    def test_test_sql_injection_not_vulnerable(self, mock_get):
        """SQL injection zafiyeti olmayan test"""
        mock_response = Mock()
        mock_response.text = "Normal web page content"
        mock_get.return_value = mock_response
        
        vulns = self.scanner._test_sql_injection("http://test.com")
        
        self.assertEqual(len(vulns), 0)
    
    @patch('requests.Session.get')
    def test_test_sql_injection_connection_error(self, mock_get):
        """SQL injection test bağlantı hatası"""
        mock_get.side_effect = requests.exceptions.ConnectionError()
        
        vulns = self.scanner._test_sql_injection("http://test.com")
        
        self.assertEqual(len(vulns), 0)
    
    @patch('requests.Session.get')
    def test_test_xss_vulnerable(self, mock_get):
        """XSS zafiyeti tespit testi"""
        # Mock response ile XSS payload reflected döndür
        mock_response = Mock()
        mock_response.text = "Search results for: <script>alert('XSS')</script>"
        mock_get.return_value = mock_response
        
        vulns = self.scanner._test_xss("http://test.com")
        
        self.assertGreater(len(vulns), 0)
        self.assertEqual(vulns[0].cve_id, "XSS-001")
        self.assertEqual(vulns[0].severity, VulnerabilityLevel.MEDIUM)
    
    @patch('requests.Session.get')
    def test_test_xss_not_vulnerable(self, mock_get):
        """XSS zafiyeti olmayan test"""
        mock_response = Mock()
        mock_response.text = "Search results for: [filtered]"
        mock_get.return_value = mock_response
        
        vulns = self.scanner._test_xss("http://test.com")
        
        self.assertEqual(len(vulns), 0)
    
    @patch('requests.Session.get')
    def test_test_directory_traversal_vulnerable(self, mock_get):
        """Directory traversal zafiyeti tespit testi"""
        # Mock response ile sistem dosyası içeriği döndür
        mock_response = Mock()
        mock_response.text = "root:x:0:0:root:/root:/bin/bash"
        mock_get.return_value = mock_response
        
        vulns = self.scanner._test_directory_traversal("http://test.com")
        
        self.assertGreater(len(vulns), 0)
        self.assertEqual(vulns[0].cve_id, "DIR-TRAV-001")
        self.assertEqual(vulns[0].severity, VulnerabilityLevel.HIGH)
    
    @patch('requests.Session.get')
    def test_test_directory_traversal_not_vulnerable(self, mock_get):
        """Directory traversal zafiyeti olmayan test"""
        mock_response = Mock()
        mock_response.text = "File not found"
        mock_get.return_value = mock_response
        
        vulns = self.scanner._test_directory_traversal("http://test.com")
        
        self.assertEqual(len(vulns), 0)
    
    @patch('requests.Session.get')
    def test_test_security_headers_missing_all(self, mock_get):
        """Tüm güvenlik başlıkları eksik test"""
        mock_response = Mock()
        mock_response.headers = {}  # Hiç güvenlik başlığı yok
        mock_get.return_value = mock_response
        
        vulns = self.scanner._test_security_headers("http://test.com")
        
        # 5 güvenlik başlığı eksik olmalı
        self.assertEqual(len(vulns), 5)
        
        header_names = [vuln.title for vuln in vulns]
        self.assertIn("Missing Security Header: X-Frame-Options", header_names)
        self.assertIn("Missing Security Header: X-Content-Type-Options", header_names)
        self.assertIn("Missing Security Header: Content-Security-Policy", header_names)
    
    @patch('requests.Session.get')
    def test_test_security_headers_all_present(self, mock_get):
        """Tüm güvenlik başlıkları mevcut test"""
        mock_response = Mock()
        mock_response.headers = {
            'X-Frame-Options': 'DENY',
            'X-Content-Type-Options': 'nosniff',
            'X-XSS-Protection': '1; mode=block',
            'Strict-Transport-Security': 'max-age=31536000',
            'Content-Security-Policy': "default-src 'self'"
        }
        mock_get.return_value = mock_response
        
        vulns = self.scanner._test_security_headers("http://test.com")
        
        self.assertEqual(len(vulns), 0)
    
    @patch('socket.socket')
    def test_scan_ssh_vulnerabilities_password_auth(self, mock_socket):
        """SSH password authentication zafiyeti testi"""
        # Mock socket ile SSH banner döndür
        mock_sock_instance = Mock()
        mock_sock_instance.recv.return_value = b"SSH-2.0-OpenSSH_7.4 password authentication enabled"
        mock_socket.return_value = mock_sock_instance
        
        vulns = self.scanner._scan_ssh_vulnerabilities("127.0.0.1", 22, "7.4")
        
        self.assertGreater(len(vulns), 0)
        self.assertEqual(vulns[0].cve_id, "SSH-WEAK-001")
        self.assertEqual(vulns[0].severity, VulnerabilityLevel.MEDIUM)
    
    @patch('socket.socket')
    def test_scan_ssh_vulnerabilities_no_issues(self, mock_socket):
        """SSH güvenlik sorunu olmayan test"""
        mock_sock_instance = Mock()
        mock_sock_instance.recv.return_value = b"SSH-2.0-OpenSSH_8.0"
        mock_socket.return_value = mock_sock_instance
        
        vulns = self.scanner._scan_ssh_vulnerabilities("127.0.0.1", 22, "8.0")
        
        self.assertEqual(len(vulns), 0)
    
    @patch('socket.socket')
    def test_scan_ftp_vulnerabilities_anonymous_access(self, mock_socket):
        """FTP anonymous access zafiyeti testi"""
        mock_sock_instance = Mock()
        mock_sock_instance.recv.side_effect = [
            b"220 FTP Server ready",  # Banner
            b"230 Anonymous user logged in"  # Anonymous login response
        ]
        mock_socket.return_value = mock_sock_instance
        
        vulns = self.scanner._scan_ftp_vulnerabilities("127.0.0.1", 21, "vsftpd 3.0.3")
        
        self.assertGreater(len(vulns), 0)
        self.assertEqual(vulns[0].cve_id, "FTP-ANON-001")
        self.assertEqual(vulns[0].severity, VulnerabilityLevel.MEDIUM)
    
    @patch('socket.socket')
    def test_scan_ftp_vulnerabilities_no_anonymous(self, mock_socket):
        """FTP anonymous access olmayan test"""
        mock_sock_instance = Mock()
        mock_sock_instance.recv.side_effect = [
            b"220 FTP Server ready",
            b"530 Login incorrect"
        ]
        mock_socket.return_value = mock_sock_instance
        
        vulns = self.scanner._scan_ftp_vulnerabilities("127.0.0.1", 21, "vsftpd 3.0.3")
        
        self.assertEqual(len(vulns), 0)
    
    @patch('socket.socket')
    def test_scan_smtp_vulnerabilities_open_relay(self, mock_socket):
        """SMTP open relay zafiyeti testi"""
        mock_sock_instance = Mock()
        mock_sock_instance.recv.side_effect = [
            b"220 mail.test.com ESMTP Postfix",  # Banner
            b"250 mail.test.com",  # HELO response
            b"250 2.1.0 Ok"  # MAIL FROM response
        ]
        mock_socket.return_value = mock_sock_instance
        
        vulns = self.scanner._scan_smtp_vulnerabilities("127.0.0.1", 25, "Postfix 3.1.0")
        
        self.assertGreater(len(vulns), 0)
        self.assertEqual(vulns[0].cve_id, "SMTP-RELAY-001")
        self.assertEqual(vulns[0].severity, VulnerabilityLevel.HIGH)
    
    @patch('socket.socket')
    def test_scan_smtp_vulnerabilities_no_relay(self, mock_socket):
        """SMTP open relay olmayan test"""
        mock_sock_instance = Mock()
        mock_sock_instance.recv.side_effect = [
            b"220 mail.test.com ESMTP Postfix",
            b"250 mail.test.com",
            b"554 5.7.1 Relay access denied"
        ]
        mock_socket.return_value = mock_sock_instance
        
        vulns = self.scanner._scan_smtp_vulnerabilities("127.0.0.1", 25, "Postfix 3.1.0")
        
        self.assertEqual(len(vulns), 0)
    
    def test_test_default_credentials(self):
        """Varsayılan kimlik bilgileri testi"""
        # Bu basit implementasyon her zaman False döndürür
        result = self.scanner._test_default_credentials("127.0.0.1", 22, "ssh")
        self.assertFalse(result)
    
    def test_scan_general_vulnerabilities_no_default_creds(self):
        """Genel güvenlik tarama - varsayılan kimlik yok"""
        vulns = self.scanner._scan_general_vulnerabilities("127.0.0.1", 80, "http")
        
        # _test_default_credentials False döndürdüğü için güvenlik açığı olmamalı
        self.assertEqual(len(vulns), 0)
    
    @patch.object(VulnerabilityScanner, '_test_default_credentials', return_value=True)
    def test_scan_general_vulnerabilities_with_default_creds(self, mock_default_creds):
        """Genel güvenlik tarama - varsayılan kimlik var"""
        vulns = self.scanner._scan_general_vulnerabilities("127.0.0.1", 80, "http")
        
        self.assertGreater(len(vulns), 0)
        self.assertEqual(vulns[0].cve_id, "DEFAULT-CRED-001")
        self.assertEqual(vulns[0].severity, VulnerabilityLevel.CRITICAL)
    
    @patch.object(VulnerabilityScanner, '_check_service_version_vulnerabilities')
    @patch.object(VulnerabilityScanner, '_scan_web_vulnerabilities')
    @patch.object(VulnerabilityScanner, '_scan_general_vulnerabilities')
    def test_scan_service_vulnerabilities_web_service(self, mock_general, mock_web, mock_version):
        """Web servisi güvenlik açığı tarama testi"""
        # Mock return values
        mock_version.return_value = [self._create_test_vulnerability("CVE-VERSION")]
        mock_web.return_value = [self._create_test_vulnerability("CVE-WEB")]
        mock_general.return_value = [self._create_test_vulnerability("CVE-GENERAL")]
        
        vulns = self.scanner.scan_service_vulnerabilities("127.0.0.1", 80, "apache", "2.4.29")
        
        self.assertEqual(len(vulns), 3)
        mock_version.assert_called_once_with("apache", "2.4.29")
        mock_web.assert_called_once_with("127.0.0.1", 80)
        mock_general.assert_called_once_with("127.0.0.1", 80, "apache")
    
    @patch.object(VulnerabilityScanner, '_check_service_version_vulnerabilities')
    @patch.object(VulnerabilityScanner, '_scan_ssh_vulnerabilities')
    @patch.object(VulnerabilityScanner, '_scan_general_vulnerabilities')
    def test_scan_service_vulnerabilities_ssh_service(self, mock_general, mock_ssh, mock_version):
        """SSH servisi güvenlik açığı tarama testi"""
        mock_version.return_value = []
        mock_ssh.return_value = [self._create_test_vulnerability("CVE-SSH")]
        mock_general.return_value = []
        
        vulns = self.scanner.scan_service_vulnerabilities("127.0.0.1", 22, "ssh", "7.4")
        
        self.assertEqual(len(vulns), 1)
        self.assertEqual(vulns[0].cve_id, "CVE-SSH")
        mock_ssh.assert_called_once_with("127.0.0.1", 22, "7.4")
    
    def test_scan_service_vulnerabilities_exception_handling(self):
        """Servis tarama exception handling testi"""
        # Geçersiz host ile exception oluştur
        vulns = self.scanner.scan_service_vulnerabilities("invalid.host.xyz", 80, "http", "1.0")
        
        # Exception durumunda boş liste döner
        self.assertEqual(len(vulns), 0)
    
    def test_generate_vulnerability_report(self):
        """Güvenlik açığı raporu oluşturma testi"""
        # Test güvenlik açıkları oluştur
        vulns = [
            self._create_test_vulnerability("CVE-CRITICAL", VulnerabilityLevel.CRITICAL),
            self._create_test_vulnerability("CVE-HIGH", VulnerabilityLevel.HIGH),
            self._create_test_vulnerability("CVE-MEDIUM", VulnerabilityLevel.MEDIUM),
            self._create_test_vulnerability("CVE-LOW", VulnerabilityLevel.LOW),
        ]
        
        report = self.scanner.generate_vulnerability_report(vulns)
        
        self.assertIsInstance(report, dict)
        self.assertIn('scan_date', report)
        self.assertIn('total_vulnerabilities', report)
        self.assertIn('severity_summary', report)
        self.assertIn('vulnerabilities', report)
        
        self.assertEqual(report['total_vulnerabilities'], 4)
        self.assertEqual(report['severity_summary']['critical'], 1)
        self.assertEqual(report['severity_summary']['high'], 1)
        self.assertEqual(report['severity_summary']['medium'], 1)
        self.assertEqual(report['severity_summary']['low'], 1)
        self.assertEqual(len(report['vulnerabilities']), 4)
    
    def test_generate_vulnerability_report_empty(self):
        """Boş güvenlik açığı raporu testi"""
        report = self.scanner.generate_vulnerability_report([])
        
        self.assertEqual(report['total_vulnerabilities'], 0)
        self.assertEqual(report['severity_summary']['critical'], 0)
        self.assertEqual(len(report['vulnerabilities']), 0)
    
    @patch('builtins.open', new_callable=mock_open)
    @patch('json.dump')
    @patch('os.makedirs')
    def test_export_report_json(self, mock_makedirs, mock_json_dump, mock_file):
        """JSON rapor export testi"""
        test_report = {
            'scan_date': '2024-01-01 12:00:00',
            'total_vulnerabilities': 2,
            'vulnerabilities': []
        }
        
        self.scanner.export_report(test_report, 'test_report', 'json')
        
        mock_makedirs.assert_called_once_with('reports', exist_ok=True)
        mock_file.assert_called_once_with('reports/test_report.json', 'w', encoding='utf-8')
        mock_json_dump.assert_called_once()
    
    @patch('builtins.open', new_callable=mock_open)
    @patch('os.makedirs')
    def test_export_report_html(self, mock_makedirs, mock_file):
        """HTML rapor export testi"""
        test_report = {
            'scan_date': '2024-01-01 12:00:00',
            'total_vulnerabilities': 1,
            'severity_summary': {'critical': 1, 'high': 0, 'medium': 0, 'low': 0, 'info': 0},
            'vulnerabilities': [{
                'cve_id': 'CVE-2024-0001',
                'title': 'Test Vulnerability',
                'severity': 'Critical',
                'cvss_score': 9.8,
                'affected_service': 'Apache',
                'description': 'Test description'
            }]
        }
        
        self.scanner.export_report(test_report, 'test_report', 'html')
        
        mock_makedirs.assert_called_once_with('reports', exist_ok=True)
        mock_file.assert_called_once_with('reports/test_report.html', 'w', encoding='utf-8')
        
        # HTML içeriği yazılmış olmalı
        written_content = ''.join(call.args[0] for call in mock_file().write.call_args_list)
        self.assertIn('<!DOCTYPE html>', written_content)
        self.assertIn('CVE-2024-0001', written_content)
        self.assertIn('Test Vulnerability', written_content)
    
    def test_generate_html_report(self):
        """HTML raporu oluşturma testi"""
        test_report = {
            'scan_date': '2024-01-01 12:00:00',
            'total_vulnerabilities': 1,
            'severity_summary': {'critical': 1, 'high': 0, 'medium': 0, 'low': 0, 'info': 0},
            'vulnerabilities': [{
                'cve_id': 'CVE-2024-0001',
                'title': 'Test Vulnerability',
                'severity': 'Critical',
                'cvss_score': 9.8,
                'affected_service': 'Apache',
                'description': 'Test description'
            }]
        }
        
        html_content = self.scanner._generate_html_report(test_report)
        
        self.assertIsInstance(html_content, str)
        self.assertIn('<!DOCTYPE html>', html_content)
        self.assertIn('<title>Güvenlik Açığı Raporu</title>', html_content)
        self.assertIn('CVE-2024-0001', html_content)
        self.assertIn('Test Vulnerability', html_content)
        self.assertIn('class="critical"', html_content)
        self.assertIn('Critical: 1', html_content)
    
    def test_session_timeout_configuration(self):
        """Session timeout konfigürasyonu testi"""
        scanner = VulnerabilityScanner(timeout=3.0)
        self.assertEqual(scanner.session.timeout, 3.0)
    
    @patch('requests.Session.get')
    def test_web_vulnerability_scan_with_https(self, mock_get):
        """HTTPS ile web güvenlik açığı tarama testi"""
        mock_response = Mock()
        mock_response.text = "Normal content"
        mock_response.headers = {}
        mock_get.return_value = mock_response
        
        vulns = self.scanner._scan_web_vulnerabilities("127.0.0.1", 443)
        
        # HTTPS URL'si kullanılmış olmalı
        expected_url = "https://127.0.0.1:443"
        # Mock çağrıları kontrol et (header testi için en az bir çağrı olmalı)
        self.assertTrue(mock_get.called)
    
    def test_multiple_vulnerability_types_in_report(self):
        """Raporda farklı güvenlik açığı tiplerinin bulunması testi"""
        vulns = [
            self._create_test_vulnerability("CVE-CRITICAL", VulnerabilityLevel.CRITICAL),
            self._create_test_vulnerability("CVE-HIGH-1", VulnerabilityLevel.HIGH),
            self._create_test_vulnerability("CVE-HIGH-2", VulnerabilityLevel.HIGH),
            self._create_test_vulnerability("CVE-MEDIUM", VulnerabilityLevel.MEDIUM),
            self._create_test_vulnerability("CVE-LOW", VulnerabilityLevel.LOW),
            self._create_test_vulnerability("CVE-INFO", VulnerabilityLevel.INFO),
        ]
        
        report = self.scanner.generate_vulnerability_report(vulns)
        
        self.assertEqual(report['total_vulnerabilities'], 6)
        self.assertEqual(report['severity_summary']['critical'], 1)
        self.assertEqual(report['severity_summary']['high'], 2)
        self.assertEqual(report['severity_summary']['medium'], 1)
        self.assertEqual(report['severity_summary']['low'], 1)
        self.assertEqual(report['severity_summary']['info'], 1)
    
    def test_vulnerability_dataclass_serialization(self):
        """Vulnerability dataclass serileştirme testi"""
        vuln = self._create_test_vulnerability("CVE-TEST")
        vuln_dict = asdict(vuln)
        
        self.assertIsInstance(vuln_dict, dict)
        self.assertIn('cve_id', vuln_dict)
        self.assertIn('title', vuln_dict)
        self.assertIn('severity', vuln_dict)
        self.assertEqual(vuln_dict['cve_id'], 'CVE-TEST')
    
    @patch('socket.socket')
    def test_network_error_handling_ssh(self, mock_socket):
        """SSH tarama ağ hatası yönetimi testi"""
        mock_socket.side_effect = socket.error("Network unreachable")
        
        vulns = self.scanner._scan_ssh_vulnerabilities("unreachable.host", 22, "7.4")
        
        # Ağ hatası durumunda boş liste döner
        self.assertEqual(len(vulns), 0)
    
    @patch('socket.socket')
    def test_network_error_handling_ftp(self, mock_socket):
        """FTP tarama ağ hatası yönetimi testi"""
        mock_socket.side_effect = socket.timeout("Connection timeout")
        
        vulns = self.scanner._scan_ftp_vulnerabilities("unreachable.host", 21, "vsftpd")
        
        self.assertEqual(len(vulns), 0)
    
    @patch('socket.socket')
    def test_network_error_handling_smtp(self, mock_socket):
        """SMTP tarama ağ hatası yönetimi testi"""
        mock_socket.side_effect = ConnectionRefusedError("Connection refused")
        
        vulns = self.scanner._scan_smtp_vulnerabilities("unreachable.host", 25, "postfix")
        
        self.assertEqual(len(vulns), 0)
    
    @patch('requests.Session.get')
    def test_web_vulnerability_scan_request_timeout(self, mock_get):
        """Web tarama request timeout testi"""
        mock_get.side_effect = requests.exceptions.Timeout("Request timeout")
        
        vulns = self.scanner._scan_web_vulnerabilities("slow.host", 80)
        
        # Timeout durumunda boş liste döner
        self.assertEqual(len(vulns), 0)
    
    @patch('requests.Session.get')
    def test_web_vulnerability_scan_connection_error(self, mock_get):
        """Web tarama bağlantı hatası testi"""
        mock_get.side_effect = requests.exceptions.ConnectionError("Connection failed")
        
        vulns = self.scanner._scan_web_vulnerabilities("unreachable.host", 80)
        
        self.assertEqual(len(vulns), 0)
    
    def test_scanner_with_custom_threads_and_timeout(self):
        """Özel thread ve timeout ayarları ile scanner testi"""
        custom_scanner = VulnerabilityScanner(timeout=2.5, max_threads=15)
        
        self.assertEqual(custom_scanner.timeout, 2.5)
        self.assertEqual(custom_scanner.max_threads, 15)
        self.assertEqual(custom_scanner.session.timeout, 2.5)
    
    def test_vulnerability_level_ordering(self):
        """Vulnerability level enum sıralama testi"""
        levels = [
            VulnerabilityLevel.LOW,
            VulnerabilityLevel.CRITICAL,
            VulnerabilityLevel.MEDIUM,
            VulnerabilityLevel.HIGH,
            VulnerabilityLevel.INFO
        ]
        
        # Her level'ın doğru string değeri olmalı
        level_values = [level.value for level in levels]
        expected_values = ["Low", "Critical", "Medium", "High", "Info"]
        
        self.assertEqual(level_values, expected_values)
    
    @patch('time.strftime')
    def test_report_timestamp(self, mock_strftime):
        """Rapor zaman damgası testi"""
        mock_strftime.return_value = "2024-01-01 12:00:00"
        
        report = self.scanner.generate_vulnerability_report([])
        
        self.assertEqual(report['scan_date'], "2024-01-01 12:00:00")
        mock_strftime.assert_called_with('%Y-%m-%d %H:%M:%S')
    
    def test_comprehensive_service_vulnerability_scan(self):
        """Kapsamlı servis güvenlik açığı tarama testi"""
        # Farklı servis tipleri için tarama testi
        services = [
            ('apache', 'http'),
            ('nginx', 'https'),
            ('openssh', 'ssh'),
            ('vsftpd', 'ftp'),
            ('postfix', 'smtp')
        ]
        
        for service, service_type in services:
            with self.subTest(service=service, service_type=service_type):
                # Her servis için tarama yapılabilmeli (exception olmamalı)
                try:
                    vulns = self.scanner.scan_service_vulnerabilities(
                        "127.0.0.1", 80, service, "1.0.0"
                    )
                    self.assertIsInstance(vulns, list)
                except Exception as e:
                    self.fail(f"Service scan failed for {service}: {str(e)}")
    
    def test_version_edge_cases(self):
        """Versiyon karşılaştırma edge case'ler"""
        test_cases = [
            # (current_version, vulnerable_version, expected_result)
            ("1.0", "1.0.0", True),  # Eksik version part
            ("1.0.0", "1.0", True),  # Eksik version part ters
            ("2.0.0-beta", "2.0.0", False),  # Beta sürüm (exception case)
            ("", "1.0.0", False),  # Boş versiyon
            ("invalid", "1.0.0", False),  # Geçersiz format
        ]
        
        for current, vulnerable, expected in test_cases:
            with self.subTest(current=current, vulnerable=vulnerable):
                try:
                    result = self.scanner._version_matches(current, vulnerable)
                    # Expected sonuç veya exception handling
                    if current == "" or current == "invalid":
                        # Bu durumlar için False beklenir
                        self.assertFalse(result)
                    # Diğer durumlar için test
                except Exception:
                    # Exception durumunda da False döner
                    result = False
                    if expected:
                        self.fail(f"Unexpected exception for {current} vs {vulnerable}")
    
    def test_thread_safety_vulnerability_scanning(self):
        """Thread güvenliği güvenlik açığı tarama testi"""
        results = []
        
        def scan_worker(service_name):
            vulns = self.scanner.scan_service_vulnerabilities(
                "127.0.0.1", 80, service_name, "1.0.0"
            )
            results.append((service_name, len(vulns)))
        
        # Birden fazla thread ile aynı anda tarama
        threads = []
        services = ['apache', 'nginx', 'openssh', 'ftp', 'smtp']
        
        for service in services:
            t = threading.Thread(target=scan_worker, args=(service,))
            threads.append(t)
            t.start()
        
        # Thread'lerin bitmesini bekle
        for t in threads:
            t.join()
        
        # Sonuçları kontrol et
        self.assertEqual(len(results), 5)
        for service_name, vuln_count in results:
            self.assertIsInstance(vuln_count, int)
            self.assertGreaterEqual(vuln_count, 0)
    
    def test_memory_usage_with_large_vulnerability_list(self):
        """Büyük güvenlik açığı listesi ile bellek kullanımı testi"""
        # Çok sayıda güvenlik açığı oluştur
        large_vuln_list = []
        for i in range(1000):
            vuln = self._create_test_vulnerability(f"CVE-2024-{i:04d}")
            large_vuln_list.append(vuln)
        
        # Rapor oluştur
        report = self.scanner.generate_vulnerability_report(large_vuln_list)
        
        self.assertEqual(report['total_vulnerabilities'], 1000)
        self.assertEqual(len(report['vulnerabilities']), 1000)
        
        # Memory cleanup
        del large_vuln_list
        del report
    
    def test_sql_injection_multiple_error_patterns(self):
        """SQL injection çoklu hata pattern testi"""
        error_patterns = [
            "mysql_fetch_array(): supplied argument is not a valid MySQL result",
            "ORA-01756: quoted string not properly terminated",
            "Microsoft OLE DB Provider for ODBC Drivers error",
            "PostgreSQL query failed: ERROR: syntax error"
        ]
        
        for error_pattern in error_patterns:
            with self.subTest(error_pattern=error_pattern):
                with patch('requests.Session.get') as mock_get:
                    mock_response = Mock()
                    mock_response.text = f"Application error: {error_pattern}"
                    mock_get.return_value = mock_response
                    
                    vulns = self.scanner._test_sql_injection("http://test.com")
                    
                    self.assertGreater(len(vulns), 0)
                    self.assertEqual(vulns[0].cve_id, "SQL-INJ-001")
    
    def test_xss_multiple_payload_types(self):
        """XSS çoklu payload tipi testi"""
        xss_payloads = [
            "<script>alert('XSS')</script>",
            "<img src=x onerror=alert('XSS')>",
            "javascript:alert('XSS')",
            "<svg onload=alert('XSS')>"
        ]
        
        for payload in xss_payloads:
            with self.subTest(payload=payload):
                with patch('requests.Session.get') as mock_get:
                    mock_response = Mock()
                    mock_response.text = f"Search: {payload}"
                    mock_get.return_value = mock_response
                    
                    vulns = self.scanner._test_xss("http://test.com")
                    
                    self.assertGreater(len(vulns), 0)
                    self.assertEqual(vulns[0].cve_id, "XSS-001")
    
    def test_directory_traversal_multiple_payloads(self):
        """Directory traversal çoklu payload testi"""
        traversal_payloads = [
            "../../../etc/passwd",
            "..\\..\\..\\windows\\system32\\drivers\\etc\\hosts",
            "....//....//....//etc/passwd",
            "%2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fpasswd"
        ]
        
        file_contents = [
            "root:x:0:0:root:/root:/bin/bash",  # /etc/passwd
            "127.0.0.1 localhost"  # hosts file
        ]
        
        for payload in traversal_payloads:
            for content in file_contents:
                with self.subTest(payload=payload, content=content):
                    with patch('requests.Session.get') as mock_get:
                        mock_response = Mock()
                        mock_response.text = content
                        mock_get.return_value = mock_response
                        
                        vulns = self.scanner._test_directory_traversal("http://test.com")
                        
                        self.assertGreater(len(vulns), 0)
                        self.assertEqual(vulns[0].cve_id, "DIR-TRAV-001")
    
    def test_security_headers_partial_missing(self):
        """Kısmi eksik güvenlik başlıkları testi"""
        partial_headers = {
            'X-Frame-Options': 'DENY',
            'X-Content-Type-Options': 'nosniff'
            # Diğer başlıklar eksik
        }
        
        with patch('requests.Session.get') as mock_get:
            mock_response = Mock()
            mock_response.headers = partial_headers
            mock_get.return_value = mock_response
            
            vulns = self.scanner._test_security_headers("http://test.com")
            
            # 3 başlık eksik olmalı
            self.assertEqual(len(vulns), 3)
            
            missing_headers = [vuln.title for vuln in vulns]
            self.assertIn("Missing Security Header: X-XSS-Protection", missing_headers)
            self.assertIn("Missing Security Header: Strict-Transport-Security", missing_headers)
            self.assertIn("Missing Security Header: Content-Security-Policy", missing_headers)
    
    def test_export_report_invalid_format(self):
        """Geçersiz format ile rapor export testi"""
        test_report = {'test': 'data'}
        
        # Desteklenmeyen format (sadece json ve html desteklenir)
        with patch('os.makedirs'):
            self.scanner.export_report(test_report, 'test', 'xml')
            # Bu durumda hiçbir dosya oluşturulmamalı (sessizce görmezden gelir)
    
    def _create_test_vulnerability(self, cve_id: str, 
                                 severity: VulnerabilityLevel = VulnerabilityLevel.MEDIUM) -> Vulnerability:
        """Test için güvenlik açığı oluşturur"""
        return Vulnerability(
            cve_id=cve_id,
            title=f"Test Vulnerability {cve_id}",
            description=f"Test description for {cve_id}",
            severity=severity,
            cvss_score=5.0,
            affected_service="Test Service",
            affected_version="1.0.0",
            solution="Test solution",
            references=[f"https://cve.mitre.org/cgi-bin/cvename.cgi?name={cve_id}"],
            exploit_available=False
        )


class TestVulnerabilityScannerIntegration(unittest.TestCase):
    """Vulnerability Scanner entegrasyon testleri"""
    
    def setUp(self):
        """Her test öncesi çağrılır"""
        self.scanner = VulnerabilityScanner(timeout=0.5, max_threads=3)
        
    def tearDown(self):
        """Her test sonrası çağrılır"""
        if hasattr(self.scanner, 'session'):
            self.scanner.session.close()
    
    def test_full_scan_workflow(self):
        """Tam tarama iş akışı testi"""
        # 1. Servis taraması
        vulns = self.scanner.scan_service_vulnerabilities(
            "127.0.0.1", 80, "apache", "2.4.29"
        )
        
        # 2. Rapor oluşturma
        report = self.scanner.generate_vulnerability_report(vulns)
        
        # 3. Rapor doğrulama
        self.assertIsInstance(report, dict)
        self.assertIn('scan_date', report)
        self.assertIn('total_vulnerabilities', report)
        self.assertIn('severity_summary', report)
        
        # 4. Export simulation (dosya oluşturmadan)
        try:
            with patch('os.makedirs'), patch('builtins.open', mock_open()):
                self.scanner.export_report(report, 'integration_test', 'json')
                self.scanner.export_report(report, 'integration_test', 'html')
        except Exception as e:
            self.fail(f"Export failed: {str(e)}")
    
    @patch('requests.Session.get')
    def test_web_service_full_scan(self, mock_get):
        """Web servisi tam tarama testi"""
        # Mock responses for different vulnerability tests
        mock_responses = [
            Mock(text="Normal content", headers={}),  # Security headers test
            Mock(text="Normal content", headers={}),  # SQL injection test
            Mock(text="Normal content", headers={}),  # XSS test  
            Mock(text="Normal content", headers={}),  # Directory traversal test
        ]
        mock_get.side_effect = mock_responses
        
        vulns = self.scanner.scan_service_vulnerabilities(
            "example.com", 80, "apache", "2.4.41"
        )
        
        # En az güvenlik başlığı eksikliği bulunmalı
        self.assertGreaterEqual(len(vulns), 0)
        
        # Eğer güvenlik açığı bulunduysa, doğru formatta olmalı
        for vuln in vulns:
            self.assertIsInstance(vuln, Vulnerability)
            self.assertIsInstance(vuln.cve_id, str)
            self.assertIsInstance(vuln.severity, VulnerabilityLevel)
    
    def test_multiple_service_types_scan(self):
        """Çoklu servis tipi tarama testi"""
        services = [
            ('apache', 'http', 80),
            ('nginx', 'https', 443),
            ('openssh', 'ssh', 22),
            ('postfix', 'smtp', 25),
            ('vsftpd', 'ftp', 21)
        ]
        
        all_vulnerabilities = []
        
        for service_name, service_type, port in services:
            vulns = self.scanner.scan_service_vulnerabilities(
                "127.0.0.1", port, service_name, "1.0.0"
            )
            all_vulnerabilities.extend(vulns)
        
        # Birleşik rapor oluştur
        combined_report = self.scanner.generate_vulnerability_report(all_vulnerabilities)
        
        self.assertIsInstance(combined_report, dict)
        self.assertEqual(
            combined_report['total_vulnerabilities'], 
            len(all_vulnerabilities)
        )


if __name__ == '__main__':
    # Test dizinlerini oluştur
    os.makedirs('reports', exist_ok=True)
    os.makedirs('data', exist_ok=True)
    
    # Test suite oluştur
    loader = unittest.TestLoader()
    suite = unittest.TestSuite()
    
    # Test sınıflarını ekle
    suite.addTests(loader.loadTestsFromTestCase(TestVulnerabilityScanner))
    suite.addTests(loader.loadTestsFromTestCase(TestVulnerabilityScannerIntegration))
    
    # Test çalıştır
    runner = unittest.TextTestRunner(verbosity=2)
    result = runner.run(suite)
    
    # Sonuç raporu
    print(f"\n{'='*70}")
    print(f"Vulnerability Scanner Test Özeti:")
    print(f"{'='*70}")
    print(f"Toplam Test: {result.testsRun}")
    print(f"Başarılı: {result.testsRun - len(result.failures) - len(result.errors)}")
    print(f"Başarısız: {len(result.failures)}")
    print(f"Hatalı: {len(result.errors)}")
    print(f"{'='*70}")
    
    # Başarısız testlerin detayları
    if result.failures:
        print(f"\nBaşarısız Testler ({len(result.failures)}):")
        for test, traceback in result.failures:
            print(f"❌ {test}: {traceback.split('AssertionError:')[-1].strip()}")
    
    # Hatalı testlerin detayları
    if result.errors:
        print(f"\nHatalı Testler ({len(result.errors)}):")
        for test, traceback in result.errors:
            print(f"💥 {test}: {traceback.split('Error:')[-1].strip()}")
    
    # Başarı durumu
    if result.wasSuccessful():
        print("\n✅ Tüm Vulnerability Scanner testleri başarılı!")
        print("🔒 Güvenlik açığı tarayıcısı hazır!")
        exit(0)
    else:
        print(f"\n❌ {len(result.failures + result.errors)} test başarısız!")
        print("🔧 Lütfen hataları düzeltin ve tekrar çalıştırın.")
        exit(1)